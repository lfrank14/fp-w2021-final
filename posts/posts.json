[
  {
    "path": "posts/data-cleaning-with-purrr/",
    "title": "Data cleaning with {purrr}",
    "description": "A tutorial for using {purrr} for data cleaning.",
    "author": [
      {
        "name": "Lea Frank",
        "url": {}
      }
    ],
    "date": "2021-06-07",
    "categories": [
      "map",
      "map_df",
      "map2"
    ],
    "contents": "\r\n\r\nContents\r\nBatch Loading\r\nCreate a list with the file paths\r\nUse purrr::map to read files\r\n\r\nData cleaning\r\nMy final solution\r\n\r\nThe {purrr} package provides a number of helpful functions for loading in multiple data files and iterating data processing steps over multiple data frames. This tutorial will provide step-by-step instructions that how just how powerful the map family of functions can be.\r\nBatch Loading\r\nThe original data files downloaded from the NHANES website were separated by year and data type (i.e. demographics and FSQ), resulting in a number of data files. Rather than loading in each file one at a time, the purrr::map family of functions provides powerful tools for loading in large amounts of data.\r\nCreate a list with the file paths\r\nThe here::here function is first used to define the path to the data files.\r\n\r\n\r\n(rootpath <- here::here(\"data\"))\r\n\r\n\r\n[1] \"/Users/leafrank/Documents/fp-w2021-final/data\"\r\n\r\nThe dir_ls function from the {fs} package creates a vector of the paths for the files listed within rootpath.\r\n\r\n\r\nfnames <- fs::dir_ls(rootpath)\r\nhead(fnames)\r\n\r\n\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2001-2002.XPT\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2003-2004.XPT\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2005-2006.XPT\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2007-2008.XPT\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2009-2010.XPT\r\n\r\nImportantly, this vector is named with the associated paths. That is, each element of the vector is attributed a name that is also a character string of the file path. I know this sounds like redundant information, but it actually comes in handy when using map_df as shown below.\r\n\r\n\r\nnames(head(fnames))\r\n\r\n\r\n[1] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\"\r\n[2] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2001-2002.XPT\"\r\n[3] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2003-2004.XPT\"\r\n[4] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2005-2006.XPT\"\r\n[5] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2007-2008.XPT\"\r\n[6] \"/Users/leafrank/Documents/fp-w2021-final/data/DEMO_2009-2010.XPT\"\r\n\r\nThe demographics and FSQ will be loaded separately since they will require different data cleaning steps. Regular expression can be used with the fs::dir_ls function to filter files that match a specific pattern.\r\n\r\n\r\n# list file paths for files that contain the pattern \"DEMO\"\r\ndemo_paths <- dir_ls(rootpath, regexp = \"DEMO\")\r\n\r\n# list file paths for files that contain the pattern \"FSQ\"\r\nfsq_paths <- dir_ls(rootpath, regexp = \"FSQ\")\r\n\r\n\r\n\r\nUse purrr::map to read files\r\nThe purrr::map family of functions allows us to iterate a function over elements of a list or vector. In this case, we want to use rio::import to read in the data files using the vectors of file paths.\r\nThere are two ways in which we can read in the data. The first option is to use the purrr::map function to read each data frame into a separate element of a list. This can be useful if you want to use map to iteration the same functions, like data cleaning, over each data frame.\r\n\r\n\r\n# Loading the data files into separate lists\r\ndemos_list <- map(demo_paths, rio::import)\r\nfsq_list <- map(demo_paths, rio::import)\r\n\r\n\r\n\r\nAnother option is to use purrr::map_df to read each data file into a single data frame. Importantly, this function allows you to specify the .id, which will create a variable to identify each iteration of the function. As I mentioned earlier, the fs::dir_ls function will assign names to each path. Using map_df on the named list of paths will generate a column in the data frame output that assigns the path name to each iteration of rio::import.\r\n\r\n\r\n# Loading the data files into a single data frame\r\ndemos <- map_dfr(demo_paths, rio::import, .id = \"file\")\r\nkable(head(demos[,1:4]))\r\n\r\n\r\nfile\r\nSEQN\r\nSDDSRVYR\r\nRIDSTATR\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n1\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n2\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n3\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n4\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n5\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/DEMO_1999-2000.XPT\r\n6\r\n1\r\n2\r\n\r\nfsq <- map_dfr(fsq_paths, rio::import, .id = \"file\")\r\nkable(head(fsq[,1:4]))\r\n\r\n\r\nfile\r\nSEQN\r\nFSD010\r\nFSD160\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n1\r\n1\r\n1\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n2\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n3\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n4\r\n2\r\n1\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n5\r\n1\r\n2\r\n/Users/leafrank/Documents/fp-w2021-final/data/FSQ_1999-2000.XPT\r\n6\r\n1\r\n2\r\n\r\nWhile both options are valid, which one you choose will ultimately depend on what you intend to do with the output. If I wanted to keep the data frames separated by year so I could more easily process and analyze the data, map would might be the better approach.\r\nIf I wanted to create a single data file that contains survey data from all years (1999-2016) that could then be shared with collaborators, I might choose to use map_dfr to create a single data frame. This option is demonstrated below in My Final Solution.\r\nLet’s take a look at how map can be used to iterate data cleaning steps over a list of data frames.\r\nData cleaning\r\nLet’s start with the list of data frames for the demographics surveys (demos_list). Each element of the list contains the demographics survey data for a specific year range (e.g. 1999-2000 or 2013-2014). If we want to apply the same data cleaning steps to each data frame, we can use map to iterate those data cleaning functions to each element of the list.\r\nFirst, let’s start by creating a variable in each data frame for the year. For this step, we can use map2 to iterate through the file paths (demo_paths) and list of data frames (demos_list) in parallel. The year will be extracted from the file path and applied to the corresponding data frame.\r\nThis time, rather than using an existing function, we can create our own. When writing a function to use within the map functions, it must be wrapped within the curly brackets ~{ [some custom function] }. To call each input, you would use .x (for the first input, demo_paths) and .y (for the second input, demos_list).\r\n\r\n\r\ndemos_list_clean <- map2(demo_paths, demos_list, ~{\r\n  # create a new variable in demos_list for th year\r\n  .y %>% \r\n    mutate(year = str_extract(.x, \"\\\\d{4}-\\\\d{4}\")) \r\n                  # extracts the pattern that matches: 4 digits-4 digits (e.g. 2001-2002)\r\n})\r\n\r\nkable(head(demos_list_clean[[1]][\"year\"]))\r\n\r\n\r\nyear\r\n1999-2000\r\n1999-2000\r\n1999-2000\r\n1999-2000\r\n1999-2000\r\n1999-2000\r\n\r\nNext, I want to select the variables of interest and rename them to something more clear. This time, I will need to return the data frame in order for it to save in the output.\r\n\r\n\r\ndemos_list_clean <- map(demos_list_clean, ~{\r\n  # selecting variables of interest\r\n  .x <- .x %>% \r\n    select(year, SEQN, RIDAGEYR, RIAGENDR, \r\n         RIDRETH1, DMDEDUC2, DMDEDUC3)\r\n  \r\n  # renaming the columns\r\n  names(.x) <- c(\"year\", \"id\",\"age\",\"gender\",\r\n                  \"race_ethnic\",\"educ_adult\",\"educ_child\")\r\n  \r\n  # return the new .x\r\n  return(.x)\r\n})\r\n\r\nkable(head(demos_list_clean[[1]]))\r\n\r\n\r\nyear\r\nid\r\nage\r\ngender\r\nrace_ethnic\r\neduc_adult\r\neduc_child\r\n1999-2000\r\n1\r\n2\r\n2\r\n4\r\nNA\r\nNA\r\n1999-2000\r\n2\r\n77\r\n1\r\n3\r\n5\r\nNA\r\n1999-2000\r\n3\r\n10\r\n2\r\n3\r\nNA\r\n3\r\n1999-2000\r\n4\r\n1\r\n1\r\n4\r\nNA\r\nNA\r\n1999-2000\r\n5\r\n49\r\n1\r\n3\r\n5\r\nNA\r\n1999-2000\r\n6\r\n19\r\n2\r\n5\r\nNA\r\n15\r\n\r\nFinally, I may want to convert some of the categorical variables into factors and add labels to the different levels.\r\n\r\n\r\ndemos_list_clean <- map(demos_list_clean, ~{\r\n  \r\n  # create new factors for gender and race/ethnicity\r\n  .x %>% \r\n    mutate(gender = factor(gender, labels = c(\"male\",\"female\")),\r\n           race_ethnic = factor(race_ethnic, labels = c(\"mexican-american\",\r\n                                                        \"other-hispanic\",\r\n                                                        \"non-hispanic-white\",\r\n                                                        \"non-hispanic-black\",\r\n                                                        \"other-race\")))\r\n})\r\n\r\nkable(head(demos_list_clean[[1]]))\r\n\r\n\r\nyear\r\nid\r\nage\r\ngender\r\nrace_ethnic\r\neduc_adult\r\neduc_child\r\n1999-2000\r\n1\r\n2\r\nfemale\r\nnon-hispanic-black\r\nNA\r\nNA\r\n1999-2000\r\n2\r\n77\r\nmale\r\nnon-hispanic-white\r\n5\r\nNA\r\n1999-2000\r\n3\r\n10\r\nfemale\r\nnon-hispanic-white\r\nNA\r\n3\r\n1999-2000\r\n4\r\n1\r\nmale\r\nnon-hispanic-black\r\nNA\r\nNA\r\n1999-2000\r\n5\r\n49\r\nmale\r\nnon-hispanic-white\r\n5\r\nNA\r\n1999-2000\r\n6\r\n19\r\nfemale\r\nother-race\r\nNA\r\n15\r\n\r\nThese steps can all be combined to produce the following code:\r\n\r\n\r\ndemos_list_clean <- map2(demo_paths, demos_list, ~{\r\n  .y <- .y %>% \r\n    mutate(year = str_extract(.x, \"\\\\d{4}-\\\\d{4}\"),\r\n           RIAGENDR = factor(RIAGENDR, labels = c(\"male\",\"female\")),\r\n           RIDRETH1 = factor(RIDRETH1, labels = c(\"mexican-american\",\r\n                                                        \"other-hispanic\",\r\n                                                        \"non-hispanic-white\",\r\n                                                        \"non-hispanic-black\",\r\n                                                        \"other-race\"))) %>% \r\n    select(year, SEQN, RIDAGEYR, RIAGENDR, \r\n         RIDRETH1, DMDEDUC2, DMDEDUC3)\r\n  names(.y) <- c(\"year\", \"id\",\"age\",\"gender\",\r\n                  \"race_ethnic\",\"educ_adult\",\"educ_child\")\r\n  return(.y)\r\n})\r\n\r\n\r\n\r\nMy final solution\r\nAs I mentioned earlier, another possible route was to read the data files into a single data frame. Since the output was intended to be shared with collaborators on this blog, I decided this was the optimal solution. The same data cleaning steps conducted above can then be applied to the single data frame.\r\n\r\n\r\ndemos <- dir_ls(rootpath, \r\n                 regexp = \"DEMO\") %>% # listing demographics files\r\n  # batch loading demographics files\r\n  map_dfr(rio::import, .id = \"file\") %>% \r\n                       # .id = \"file\" creates a variable with the file name\r\n  # creating a variable for year from the file name id\r\n  mutate(year = str_extract(file, \"\\\\d{4}-\\\\d{4}\"), \r\n         # creating factors for gender and race/ethnicity \r\n         RIAGENDR = factor(RIAGENDR, labels = c(\"male\",\"female\")),\r\n         RIDRETH1 = factor(RIDRETH1, labels = c(\"mexican-american\",\r\n                                                \"other-hispanic\",\r\n                                                \"non-hispanic-white\",\r\n                                                \"non-hispanic-black\",\r\n                                                \"other-race\"))) %>% \r\n  # selecting variables of interest\r\n  select(year, SEQN, RIDAGEYR, RIAGENDR, \r\n         RIDRETH1, DMDEDUC2, DMDEDUC3)\r\n\r\n# renaming the columns into something more legible\r\nnames(demos) <- c(\"year\", \"id\",\"age\",\"gender\",\r\n                  \"race_ethnic\",\"educ_adult\",\"educ_child\") \r\n\r\nfsq <- dir_ls(rootpath, \r\n                 regexp = \"FSQ\") %>% # listing questionnaire files\r\n  # batch importing questionnaire files\r\n  map_dfr(rio::import, .id = \"file\") %>% \r\n                       # .id = \"file\" creates a variable with the file name\r\n  # creating new variables for year and food security\r\n  mutate(year = str_extract(file, \"\\\\d{4}-\\\\d{4}\"), \r\n         hh_food_secure = ifelse(year == \"1999-2000\" | year == \"2001-2002\", \r\n                                 HHFDSEC, FSDHH)) %>% \r\n  # selecting variables of interest\r\n  select(year, SEQN, hh_food_secure) \r\n\r\n# renaming the 'SEQN' column so that it can be joined with the demographics data\r\nnames(fsq)[2] <- \"id\" \r\n\r\n\r\n\r\nAfter creating data frames for the demographics and FSQ data, they were then joined by the year and id.\r\n\r\n\r\ndf <- left_join(demos, fsq)\r\nkable(head(df))\r\n\r\n\r\nyear\r\nid\r\nage\r\ngender\r\nrace_ethnic\r\neduc_adult\r\neduc_child\r\nhh_food_secure\r\n1999-2000\r\n1\r\n2\r\nfemale\r\nnon-hispanic-black\r\nNA\r\nNA\r\n1\r\n1999-2000\r\n2\r\n77\r\nmale\r\nnon-hispanic-white\r\n5\r\nNA\r\n1\r\n1999-2000\r\n3\r\n10\r\nfemale\r\nnon-hispanic-white\r\nNA\r\n3\r\n1\r\n1999-2000\r\n4\r\n1\r\nmale\r\nnon-hispanic-black\r\nNA\r\nNA\r\n4\r\n1999-2000\r\n5\r\n49\r\nmale\r\nnon-hispanic-white\r\n5\r\nNA\r\n1\r\n1999-2000\r\n6\r\n19\r\nfemale\r\nother-race\r\nNA\r\n15\r\n1\r\n\r\nFinally, the data frame was saved into a single .csv file that could then be shared with collaborators.\r\n\r\n\r\nwrite_csv(df, str_c(rootpath,\"/nhanes_1999-2016.csv\"))\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-06-08T14:31:48-07:00",
    "input_file": {}
  },
  {
    "path": "posts/parallel-iteration/",
    "title": "Parallel Iteration",
    "description": "Using `nest` with `map2_*` or `pmap_*` in `{purrr}`.",
    "author": [
      {
        "name": "Wanjia Guo",
        "url": {}
      }
    ],
    "date": "2021-05-20",
    "categories": [],
    "contents": "\r\nIn this post, we will dive deeper into the {purrr} package. We will explore purrr::nest %>% mutate(), which is an alternative to the split() function in the base-R. Moreover, we will see how the combination of purrr::nest %>% mutate() with map2_* or pmap_* can be a powerful tool in functional programming.\r\nThe data we will use is taken from the National Health and Nutrition Examination Survey (NHANES). Each year, the survey collects information on the health and nutritional status of children and adults across the United States. For the current blog, survey data was taken from the years 1999 - 2016. The data was narrowed down to the following variables of interest for the current post:\r\n\r\nVariable Code\r\nType\r\nDescription\r\nyear\r\nString\r\nThe year that data was collected\r\nid\r\nInteger\r\nRespondent ID\r\nage\r\nInteger\r\nAge in years at screening\r\ngender\r\nCategory\r\nGender: male or female\r\nrace_ethnic\r\nCategory\r\nRace/Hispanic origin: mexican-american, non-hispanic-black, non-hispanic-white, other-hispanic, other-race\r\nhh_food_secure\r\nInteger\r\nHousehold food security category over last 12 months\r\nage_group\r\nBinary\r\nAge group: adult(20+) or child(6-19)\r\neduc\r\nInteger\r\nEducation level for adults 20+ and children/youth 6-19\r\n\r\nLet’s take a look at the dataframe.\r\n\r\n\r\nhead(df)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  year      id   age gender race_ethnic hh_food_secure age_group  educ\r\n  <chr>  <dbl> <dbl> <fct>  <fct>                <dbl> <fct>     <dbl>\r\n1 1999-…     2    77 male   non-hispan…              1 adult         5\r\n2 1999-…     3    10 female non-hispan…              1 child         3\r\n3 1999-…     5    49 male   non-hispan…              1 adult         5\r\n4 1999-…     6    19 female other-race               1 child        15\r\n5 1999-…     8    13 male   non-hispan…              1 child         5\r\n6 1999-…     9    11 female non-hispan…              2 child         5\r\n\r\nWe are interested in how food secure changes over time, separated by gender and age group (child and adult). For the first step, we want to split the dataframe into lists with split as the following. However, the three grouping variables (gender, age group, and year) are merged together into one column. This is less desirable because we will need each of these variables for later.\r\n\r\n\r\nsplit_df = split(df, list(df$gender, df$age_group, df$year))\r\n\r\nhead(split_df$`female.adult.1999-2000`)\r\n\r\n\r\n# A tibble: 6 x 8\r\n  year      id   age gender race_ethnic hh_food_secure age_group  educ\r\n  <chr>  <dbl> <dbl> <fct>  <fct>                <dbl> <fct>     <dbl>\r\n1 1999-…    15    38 female non-hispan…              1 adult         5\r\n2 1999-…    16    85 female non-hispan…              4 adult         1\r\n3 1999-…    20    23 female mexican-am…              1 adult         1\r\n4 1999-…    24    53 female non-hispan…              1 adult         3\r\n5 1999-…    25    42 female non-hispan…              1 adult         4\r\n6 1999-…    34    38 female non-hispan…              3 adult         3\r\n\r\nEquivalently, we can also use nest from the {purrr} package as the following:\r\n\r\n\r\nnest_df = df %>% group_by(year, age_group, gender) %>% nest()\r\n\r\nhead(nest_df)\r\n\r\n\r\n# A tibble: 6 x 4\r\n# Groups:   year, gender, age_group [6]\r\n  year      gender age_group data                \r\n  <chr>     <fct>  <fct>     <list>              \r\n1 1999-2000 male   adult     <tibble [2,211 × 5]>\r\n2 1999-2000 female child     <tibble [1,698 × 5]>\r\n3 1999-2000 male   child     <tibble [1,744 × 5]>\r\n4 1999-2000 female adult     <tibble [2,534 × 5]>\r\n5 2001-2002 male   adult     <tibble [2,384 × 5]>\r\n6 2001-2002 female adult     <tibble [2,669 × 5]>\r\n\r\nThese two approaches ends with very similar results, only except gener, age_group, and year are maintaned as its orignal structure with nest but not split.\r\nMoreover, with nest, we can manipulate the dataframe within each row while save the output as another column. We will calculate within each gender, age group and year, how food security changes with age. (If you find the map function confusing, I encourage you take a look at this post.)\r\n\r\n\r\nmodel_df = nest_df %>% mutate(n = map_dbl(data, nrow),\r\n                   m1 = map(data, ~lm(hh_food_secure ~ age, data = .x)),\r\n                   coefs = map(m1, coef),\r\n                   intercept = map_dbl(coefs, 1),\r\n                   slope = map_dbl(coefs, 2))\r\n\r\nhead(model_df)\r\n\r\n\r\n# A tibble: 6 x 9\r\n# Groups:   year, gender, age_group [6]\r\n  year   gender age_group data        n m1    coefs intercept    slope\r\n  <chr>  <fct>  <fct>     <list>  <dbl> <lis> <lis>     <dbl>    <dbl>\r\n1 1999-… male   adult     <tibbl…  2211 <lm>  <dbl…      1.60 -4.91e-3\r\n2 1999-… female child     <tibbl…  1698 <lm>  <dbl…      1.57 -1.86e-4\r\n3 1999-… male   child     <tibbl…  1744 <lm>  <dbl…      1.69 -2.03e-4\r\n4 1999-… female adult     <tibbl…  2534 <lm>  <dbl…      1.58 -4.25e-3\r\n5 2001-… male   adult     <tibbl…  2384 <lm>  <dbl…      1.75 -7.29e-3\r\n6 2001-… female adult     <tibbl…  2669 <lm>  <dbl…      1.70 -6.58e-3\r\n\r\nLet’s take a look at how the slope change with time:\r\n\r\n\r\nmodel_df %>% ggplot(aes(x=year, y=slope, color=age_group, group = age_group)) + \r\n  geom_line(size = 1.5) + \r\n  facet_wrap(~gender, nrow = 2) +\r\n  theme(legend.position = 'bottom') + \r\n  labs(y = 'Slope: Age and Food Security',\r\n       x = 'Year',\r\n       color = 'Age Group')\r\n\r\n\r\n\r\n\r\nFrom the figure, we can see that for adults, the slope is consistently negative across all time. In other words, as people age, the food security score decreased. However, for children, the food security increased dramatically recently, especially since 2010s. What if we want to dig deeper and see how age influence children’s food security within each year for different gender?\r\nLet’s start with only one row of data:\r\n\r\n\r\nchild_model_df = model_df %>% filter(age_group == 'child')\r\n\r\nplotting <- function(df, gender, year = NULL){\r\n  \r\n  p = df %>% \r\n    group_by(age, race_ethnic) %>% \r\n    summarise(m = mean(hh_food_secure),\r\n              sd = sd(hh_food_secure)) %>% \r\n    ggplot(aes(x=age,\r\n               y=m,\r\n               color = race_ethnic))+\r\n    geom_line(alpha = 0.7, size = 1.5) +\r\n    theme(legend.position = 'bottom')+\r\n    labs(x = 'Age',\r\n         y = 'Food Secure Score',\r\n         color = 'Race and Ethnic') + \r\n    guides(color=guide_legend(nrow=2, byrow=TRUE))\r\n  \r\n  if(missing(year)){\r\n    p = p + labs(title = gender)\r\n  }else{\r\n    p = p + labs(title = paste(year, gender, sep = \": \"))}\r\n\r\n  p\r\n  \r\n  }\r\n\r\n# make sure the funtion works for one row of data.\r\nplotting(child_model_df$data[[1]], \r\n         child_model_df$gender[[1]], \r\n         child_model_df$year[[1]])\r\n\r\n\r\n\r\n\r\nWith pmap_*, we can easily use the above code to produce figures for each row. When using pmap_*, the first input is a list of column names that we need from the dataframe and the second input is the plotting function we used in the last part. The ..1, ..2, and ..3 are corresponding to data, gender, and year. Then, Voila, you have a figure for data from each row!\r\n\r\n\r\nchild_model_plot_df <- child_model_df %>% \r\n  mutate(nest_plot = pmap(list(data, gender, year),\r\n                          ~{plotting(..1, ..2, ..3)})\r\n                          )\r\n\r\nggpubr::ggarrange(child_model_plot_df$nest_plot[[1]],\r\n                  child_model_plot_df$nest_plot[[2]],\r\n                  child_model_plot_df$nest_plot[[17]],\r\n                  child_model_plot_df$nest_plot[[18]],\r\n                  ncol = 2, nrow = 2,\r\n                  common.legend = TRUE,\r\n                  legend = 'bottom')\r\n\r\n\r\n\r\n\r\nAnother cool thing about nest, is that we can easily reverse this process with unnest after we finished our grouped analysis.\r\n\r\n\r\nadult_df = model_df %>% \r\n  filter(age_group == 'adult') %>%\r\n  select(year, gender, age_group, data) %>% unnest(data)\r\nhead(adult_df)\r\n\r\n\r\n# A tibble: 6 x 8\r\n# Groups:   year, gender, age_group [1]\r\n  year   gender age_group    id   age race_ethnic hh_food_secure  educ\r\n  <chr>  <fct>  <fct>     <dbl> <dbl> <fct>                <dbl> <dbl>\r\n1 1999-… male   adult         2    77 non-hispan…              1     5\r\n2 1999-… male   adult         5    49 non-hispan…              1     5\r\n3 1999-… male   adult        12    37 non-hispan…              1     4\r\n4 1999-… male   adult        13    70 mexican-am…              1     1\r\n5 1999-… male   adult        14    81 non-hispan…              1     2\r\n6 1999-… male   adult        29    62 non-hispan…              1     3\r\n\r\nLastly, once we learned about pmap_*, map2_* is very similar. Instead of being able to use as many variables you need with pmap, map2 is specialized for only 2 inputs. Let’s see an example below. Since we have found that the relationship between age and food secure are pretty consistent over the years, let’s make a plot that ignore the age factor with map2.\r\n\r\n\r\nadult_plot_df = adult_df %>% \r\n  group_by(gender) %>% \r\n  nest() %>% \r\n  mutate(nest_plot = map2(data, gender,\r\n                          ~plotting(.x, .y)))\r\n\r\nggpubr::ggarrange(adult_plot_df$nest_plot[[1]],\r\n                  adult_plot_df$nest_plot[[2]],\r\n                  ncol = 2,\r\n                  common.legend = TRUE,\r\n                  legend = 'bottom')\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/parallel-iteration/parallel-iteration_files/figure-html5/unnamed-chunk-5-1.png",
    "last_modified": "2021-06-08T14:31:48-07:00",
    "input_file": {},
    "preview_width": 1920,
    "preview_height": 1152
  },
  {
    "path": "posts/looping/",
    "title": "Looping",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Meg Siritzky",
        "url": {}
      }
    ],
    "date": "2021-05-13",
    "categories": [],
    "contents": "\r\nThe question we’re trying to answer is what is the change in the relationship between age and percentage of the population experiencing food insecurity over time.\r\nFirst we’ll import our data using the here package.\r\n\r\n\r\nfi <- import(here(\"data\", \"nhanes_1999-2016.csv\"))\r\n\r\n\r\n\r\nNext, we’re going to convert the food insecurity variable to a factor, rename the levels, and remove NAs.\r\n\r\n\r\nfi_factor <- fi %>% \r\n  mutate(security = as_factor(hh_food_secure)) %>% \r\n  mutate(security = case_when(\r\n    security == \"1\" ~ \"full food security\",\r\n    security == \"2\" ~ \"marginal food security\",\r\n    security == \"3\" ~ \"low food security\",\r\n    security == \"4\" ~ \"very low food security\")) %>% \r\n  filter(security != is.na(security))\r\n\r\n\r\n\r\nWe want to get the percentage of the population that falls in each food security group at each time point, so we’re going to first count the number of people in each group in each year and the population in each year, and then create a new column called percent_insecurity that has the percentage of people in the population that report that level of food security.\r\n\r\n\r\nfi_factor <- fi_factor %>% \r\n  add_count(year, name = \"pop\") %>% \r\n  add_count(year, security, name = \"ct\") %>% \r\n  dplyr::select(year, security, age, pop, ct) %>% \r\n  mutate(pop = as.numeric(pop),\r\n         ct = as.numeric(ct),\r\n         percent_insecurity = ct/pop)\r\n\r\n\r\n\r\nNow we use the group_by and nest functions to create a nested data frame that groups our data by year and level of food insecurity.\r\n\r\n\r\nfi_grouped <- fi_factor %>% \r\n  group_by(year, security) %>% \r\n  nest()\r\n\r\n\r\n\r\nWe’re want to look at the linear relationship between age and percent of food insecurity over time. To do this, we fit a linear regression model predicting food insecurity from age using map. We can then extract the intercepts and slopes of each model using map_dbl. I’m going to want to use our percent_insecurity variable later, so to move it from a nested list to the main data frame, I unnest the data list and then save that column.\r\n\r\n\r\nfi_grouped_lm <- fi_grouped %>% \r\n  mutate(m1 = map(data, ~lm(percent_insecurity ~ age, data = .x)),\r\n         coefs = map(m1, coefficients),\r\n         intercept = map_dbl(coefs, 1),\r\n         slope = map_dbl(coefs, 2)) %>% \r\n  unnest(data) %>% \r\n  dplyr::select(year, security, intercept, slope, percent_insecurity)\r\n\r\n\r\n\r\nNow we want to look at the change in slope of how age predicts food insecurity across time. So I’m creating a line graph where the x axis is year and the y-axis is slope, and I’m visualizing to see the change in slope over time. I’m using the pmap and list functions to create a new list in our nested data frame with a plot for each level of food security.\r\n\r\n\r\nfi_grouped_plots <- fi_grouped_lm %>%\r\n  group_by(security) %>%\r\n  nest() %>%\r\n  mutate(plot = pmap(list(security, data), ~{\r\n    ggplot(..2, aes(year, slope)) +\r\n      geom_point() +\r\n      geom_line() +\r\n      labs(title = glue(\"Slope of relation between age and {.x} by year\"),\r\n           x = \"Year\",\r\n           y = \"Slope\")\r\n    })\r\n    )\r\n\r\n\r\n\r\nHere’s an example of one of the plots.\r\n\r\n\r\nfi_grouped_plots$plot[[2]]\r\n\r\n\r\n\r\n\r\nNow I’m going to export a plot for each level of food security using walk2.\r\n\r\n\r\nfs::dir_create(here::here(\"plots\", \"slope_plots\"))\r\nfood_security_groups <- str_replace_all(tolower(fi_grouped_plots$security), \" \", \"-\")\r\npaths <- here::here(\"plots\", \"slope_plots\", glue(\"age_{food_security_groups}.png\"))\r\n\r\nwalk2(paths, fi_grouped_plots$plot, ggsave,\r\n      width = 9.5, \r\n      height = 6.5,\r\n      dpi = 500)\r\n\r\n\r\n\r\nNow I want to look at the change in percent of different levels of food security across time. So, again, I’m using the the pmap and list functions to create a new list in our nested data frame with bar graphs where the x axis is year and the y-axis is percent of food security.\r\n\r\n\r\nfi_grouped_plots_2 <- fi_grouped_lm %>%\r\n  group_by(security) %>%\r\n  nest() %>%\r\n  mutate(plot = pmap(list(security, data), ~{\r\n    ggplot(..2, aes(year, percent_insecurity)) +\r\n      geom_point() +\r\n      labs(title = glue(\"Percent of {.x} in the population by year\"),\r\n           x = \"Year\",\r\n           y = \"Percent\")\r\n    })\r\n    )\r\n\r\n\r\n\r\nHere’s an example of one of the plots.\r\n\r\n\r\nfi_grouped_plots_2$plot[[2]]\r\n\r\n\r\n\r\n\r\nAgain, I’m going to export a plot for each level of food security using walk2.\r\n\r\n\r\nfs::dir_create(here::here(\"plots\", \"percent_plots\"))\r\npaths_2 <- here::here(\"plots\", \"percent_plots\", glue(\"percent_{food_security_groups}.png\"))\r\n\r\nwalk2(paths_2, fi_grouped_plots_2$plot, ggsave,\r\n      width = 9.5, \r\n      height = 6.5,\r\n      dpi = 500)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/looping/looping_files/figure-html5/unnamed-chunk-6-1.png",
    "last_modified": "2021-06-08T14:31:48-07:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/writing-functions/",
    "title": "Writing Functions",
    "description": "This is a tutorial for how to write a function in R.",
    "author": [
      {
        "name": "Sarah Dimakis",
        "url": {}
      }
    ],
    "date": "2021-05-13",
    "categories": [
      "custom functions"
    ],
    "contents": "\r\n\r\nContents\r\nLoad libraries and read in data\r\nFunctions\r\nDefault settings\r\nWarnings\r\nExample function 1\r\nExample function 2\r\nTables\r\n\r\nLoad libraries and read in data\r\nFor this tutorial, you will first need to load tidyverse for data wrangling and kableExtra for tables. Next, I am using rio::import to import the cleaned data file to my environment. Note, you may need to change the file path if your file structure is not the same as mine. Last, I am using mutate and case_when to label the levels of the food_secure variable.\r\n\r\n\r\nlibrary(tidyverse)\r\nlibrary(kableExtra)\r\n\r\ndata <- rio::import(here::here(\"data\", \"nhanes_1999-2016.csv\")) %>% \r\n  mutate(food_security = case_when(hh_food_secure == 1 ~ \"Fully food secure\",\r\n            hh_food_secure == 2 ~ \"Marginally food secure\",\r\n            hh_food_secure == 3 ~ \"Food insecure without hunger\",\r\n            hh_food_secure == 4 ~ \"Food insecure with hunger\"))\r\n\r\n\r\n\r\nFunctions\r\nA function is code that carries out an operation. For example + is a function that carries out the operation addition.\r\n\r\n\r\n2 + 3\r\n\r\n\r\n[1] 5\r\n\r\nIn algebra, you may recall learning functions such as \\(f(x,y) = x^2+y\\), where you put in inputs x = 2 and y = 1, the function computes the operation, \\(2^2+1\\), and outputs \\(5\\). Similarly, when using a function in R, it takes a form like f(x,y,z..) where f is the function name and x,y,z… are the arguments of the function.\r\n\r\n\r\n`+`(2,3)\r\n\r\n\r\n[1] 5\r\n\r\nLet’s create our first function in R called my_pet() that will print out a statement about your pet. For best practice, you should try to name your function something descriptive. It should also not be named another function that is popular like mean because it will overwrite the default mean function for your script.\r\n\r\n\r\nmy_pet <- function(pronoun, animal, verb){\r\n  paste0(str_to_title(pronoun), \" is a \", animal, \" who likes to \", verb, \".\")\r\n}\r\n\r\n\r\n\r\nThe arguments of the function (which are called formals) are what the user supplies the function to get their desired output. You can see the formals of a function in R by using the formals() function.\r\n\r\n\r\nformals(my_pet)\r\n\r\n\r\n$pronoun\r\n\r\n\r\n$animal\r\n\r\n\r\n$verb\r\n\r\nThe body of the function is where the function takes in the formals and creates the output. You can see the body of a function in R by using the body() function.\r\n\r\n\r\nbody(my_pet)\r\n\r\n\r\n{\r\n    paste0(str_to_title(pronoun), \" is a \", animal, \" who likes to \", \r\n        verb, \".\")\r\n}\r\n\r\nNow, in order to use the function, you can supply it with your desired formals.\r\n\r\n\r\nmy_pet(pronoun = \"she\", \r\n       animal = \"dog\", \r\n       verb = \"play outside\")\r\n\r\n\r\n[1] \"She is a dog who likes to play outside.\"\r\n\r\nWhen you use your function, you can drop the argument names as long as you keep the same order.\r\n\r\n\r\nmy_pet(\"he\", \"cat\", \"sleep\")\r\n\r\n\r\n[1] \"He is a cat who likes to sleep.\"\r\n\r\nIf you want to use arguments out of the order they were defined in, you will need to label them.\r\n\r\n\r\nmy_pet(animal = \"lizard\",\r\n       pronoun =\"she\", \r\n       verb = \"eat\")\r\n\r\n\r\n[1] \"She is a lizard who likes to eat.\"\r\n\r\nDefault settings\r\nYou can set a “default” setting for an argument. This is the setting that occurs when the user does not specify the argument.\r\n\r\n\r\nmy_pet2 <- function(pronoun, animal, verb = \"dance\"){\r\n  paste0(str_to_title(pronoun), \" is a \", animal, \" who likes to \", verb, \".\")\r\n}\r\n\r\n\r\n\r\n\r\n\r\nmy_pet2(pronoun = \"she\",\r\n        animal = \"dog\")\r\n\r\n\r\n[1] \"She is a dog who likes to dance.\"\r\n\r\nThe user can overwrite the default.\r\n\r\n\r\nmy_pet2(pronoun = \"she\",\r\n        animal = \"dog\",\r\n        verb = \"cuddle\")\r\n\r\n\r\n[1] \"She is a dog who likes to cuddle.\"\r\n\r\nWarnings\r\nIf someone else (or your future self) is going to use your function, it is helpful to embed warnings (via warning()) or errors (via stop()) into your code to explain why the code will not work (or if it will not work as expected).\r\n\r\n\r\n# I am using an if else structure\r\n# If the user inputs \"cat\" for animal, the function will throw an error and say \"This function doesn't work for people who own cats\"\r\n# If they use input any other animal, it will work\r\n\r\nmy_pet3 <- function(pronoun, animal, verb = \"stretch\"){\r\n  if(animal == \"cat\"){\r\n    stop(\"This function doesn't work for people who own cats.\")\r\n  }\r\n  else{\r\n    paste0(str_to_title(pronoun), \" is a \", animal, \" who likes to \", verb, \".\")\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# This works\r\nmy_pet3(\"she\", \"dog\")\r\n\r\n\r\n[1] \"She is a dog who likes to stretch.\"\r\n\r\n# This throws an error\r\nmy_pet3(\"he\", \"cat\")\r\n\r\n\r\nError in my_pet3(\"he\", \"cat\"): This function doesn't work for people who own cats.\r\n\r\nExample function 1\r\nWhat makes a particularly good function is code that you write a lot. Additionally, you want to make a function that is simple and only does one thing. For this first function, I am going to create a function that will create a “total” column that calculates the total observations across a grouping variable.\r\nBefore I create a function, I first like to try to make it work in a single case.\r\n\r\n\r\na <- count(data, year, gender)\r\na\r\n\r\n\r\n        year gender    n\r\n1  1999-2000 female 5082\r\n2  1999-2000   male 4883\r\n3  2001-2002 female 5708\r\n4  2001-2002   male 5331\r\n5  2003-2004 female 5152\r\n6  2003-2004   male 4970\r\n7  2005-2006 female 5268\r\n8  2005-2006   male 5080\r\n9  2007-2008 female 5053\r\n10 2007-2008   male 5096\r\n11 2009-2010 female 5312\r\n12 2009-2010   male 5225\r\n13 2011-2012 female 4900\r\n14 2011-2012   male 4856\r\n15 2013-2014 female 5172\r\n16 2013-2014   male 5003\r\n17 2015-2016 female 5079\r\n18 2015-2016   male 4892\r\n\r\nb <- count(data, year)\r\nb\r\n\r\n\r\n       year     n\r\n1 1999-2000  9965\r\n2 2001-2002 11039\r\n3 2003-2004 10122\r\n4 2005-2006 10348\r\n5 2007-2008 10149\r\n6 2009-2010 10537\r\n7 2011-2012  9756\r\n8 2013-2014 10175\r\n9 2015-2016  9971\r\n\r\nb <- rename(b, \"total\" = \"n\")\r\nb\r\n\r\n\r\n       year total\r\n1 1999-2000  9965\r\n2 2001-2002 11039\r\n3 2003-2004 10122\r\n4 2005-2006 10348\r\n5 2007-2008 10149\r\n6 2009-2010 10537\r\n7 2011-2012  9756\r\n8 2013-2014 10175\r\n9 2015-2016  9971\r\n\r\nleft_join(a,b)\r\n\r\n\r\n        year gender    n total\r\n1  1999-2000 female 5082  9965\r\n2  1999-2000   male 4883  9965\r\n3  2001-2002 female 5708 11039\r\n4  2001-2002   male 5331 11039\r\n5  2003-2004 female 5152 10122\r\n6  2003-2004   male 4970 10122\r\n7  2005-2006 female 5268 10348\r\n8  2005-2006   male 5080 10348\r\n9  2007-2008 female 5053 10149\r\n10 2007-2008   male 5096 10149\r\n11 2009-2010 female 5312 10537\r\n12 2009-2010   male 5225 10537\r\n13 2011-2012 female 4900  9756\r\n14 2011-2012   male 4856  9756\r\n15 2013-2014 female 5172 10175\r\n16 2013-2014   male 5003 10175\r\n17 2015-2016 female 5079  9971\r\n18 2015-2016   male 4892  9971\r\n\r\n\r\n\r\ntotal_grouping <- function(data, var, grouping){\r\n  v1 <- enquo(var) \r\n  v2 <- enquo(grouping)\r\n  \r\n  a <- count(data, !!v1, !!v2)\r\n  b <- count(data, !!v1)\r\n  b <- rename(b, \"total\" = \"n\")\r\n  c <- left_join(a,b)\r\n  na.omit(c)\r\n}\r\n\r\n\r\n\r\n\r\n\r\ntotal_grouping(data, year, gender)\r\n\r\n\r\n        year gender    n total\r\n1  1999-2000 female 5082  9965\r\n2  1999-2000   male 4883  9965\r\n3  2001-2002 female 5708 11039\r\n4  2001-2002   male 5331 11039\r\n5  2003-2004 female 5152 10122\r\n6  2003-2004   male 4970 10122\r\n7  2005-2006 female 5268 10348\r\n8  2005-2006   male 5080 10348\r\n9  2007-2008 female 5053 10149\r\n10 2007-2008   male 5096 10149\r\n11 2009-2010 female 5312 10537\r\n12 2009-2010   male 5225 10537\r\n13 2011-2012 female 4900  9756\r\n14 2011-2012   male 4856  9756\r\n15 2013-2014 female 5172 10175\r\n16 2013-2014   male 5003 10175\r\n17 2015-2016 female 5079  9971\r\n18 2015-2016   male 4892  9971\r\n\r\nNow I can do it with other variables!\r\n\r\n\r\ntotal_grouping(data, year, race_ethnic) %>% \r\n  head(10)\r\n\r\n\r\n        year        race_ethnic    n total\r\n1  1999-2000   mexican-american 3393  9965\r\n2  1999-2000 non-hispanic-black 2228  9965\r\n3  1999-2000 non-hispanic-white 3367  9965\r\n4  1999-2000     other-hispanic  589  9965\r\n5  1999-2000         other-race  388  9965\r\n6  2001-2002   mexican-american 2776 11039\r\n7  2001-2002 non-hispanic-black 2681 11039\r\n8  2001-2002 non-hispanic-white 4606 11039\r\n9  2001-2002     other-hispanic  517 11039\r\n10 2001-2002         other-race  459 11039\r\n\r\ntotal_grouping(data, year, food_security) %>% \r\n  head(10)\r\n\r\n\r\n        year                food_security    n total\r\n1  1999-2000    Food insecure with hunger  499  9965\r\n2  1999-2000 Food insecure without hunger 1209  9965\r\n3  1999-2000            Fully food secure 7102  9965\r\n4  1999-2000       Marginally food secure  889  9965\r\n6  2001-2002    Food insecure with hunger  627 11039\r\n7  2001-2002 Food insecure without hunger 1289 11039\r\n8  2001-2002            Fully food secure 7503 11039\r\n9  2001-2002       Marginally food secure  938 11039\r\n11 2003-2004    Food insecure with hunger  641 10122\r\n12 2003-2004 Food insecure without hunger 1232 10122\r\n\r\nExample function 2\r\nYou can use a previous function you have defined earlier in a script in a new function! Here, I am extending the previous function to make a column that will calculate the percentage of the count in a given year.\r\nLet’s first try an example.\r\n\r\n\r\ntotal_grouping(data, year, gender) %>% \r\n  mutate(percent = n/total * 100,\r\n         percent = round(percent, 2),\r\n         percent = paste0(percent, \"%\"))\r\n\r\n\r\n        year gender    n total percent\r\n1  1999-2000 female 5082  9965     51%\r\n2  1999-2000   male 4883  9965     49%\r\n3  2001-2002 female 5708 11039  51.71%\r\n4  2001-2002   male 5331 11039  48.29%\r\n5  2003-2004 female 5152 10122   50.9%\r\n6  2003-2004   male 4970 10122   49.1%\r\n7  2005-2006 female 5268 10348  50.91%\r\n8  2005-2006   male 5080 10348  49.09%\r\n9  2007-2008 female 5053 10149  49.79%\r\n10 2007-2008   male 5096 10149  50.21%\r\n11 2009-2010 female 5312 10537  50.41%\r\n12 2009-2010   male 5225 10537  49.59%\r\n13 2011-2012 female 4900  9756  50.23%\r\n14 2011-2012   male 4856  9756  49.77%\r\n15 2013-2014 female 5172 10175  50.83%\r\n16 2013-2014   male 5003 10175  49.17%\r\n17 2015-2016 female 5079  9971  50.94%\r\n18 2015-2016   male 4892  9971  49.06%\r\n\r\nOkay, now we’re ready to generalize.\r\n\r\n\r\npercent_grouping <- function(data, var, grouping){\r\n  v1 <- enquo(var) \r\n  v2 <- enquo(grouping)\r\n  \r\n  total_grouping(data, !!v1, !!v2) %>% \r\n  mutate(percent = n/total * 100,\r\n         percent = round(percent, 2),\r\n         percent = paste0(percent, \"%\")) \r\n}\r\n\r\n\r\n\r\n\r\n\r\ntotal_grouping(data, year, gender)\r\n\r\n\r\n        year gender    n total\r\n1  1999-2000 female 5082  9965\r\n2  1999-2000   male 4883  9965\r\n3  2001-2002 female 5708 11039\r\n4  2001-2002   male 5331 11039\r\n5  2003-2004 female 5152 10122\r\n6  2003-2004   male 4970 10122\r\n7  2005-2006 female 5268 10348\r\n8  2005-2006   male 5080 10348\r\n9  2007-2008 female 5053 10149\r\n10 2007-2008   male 5096 10149\r\n11 2009-2010 female 5312 10537\r\n12 2009-2010   male 5225 10537\r\n13 2011-2012 female 4900  9756\r\n14 2011-2012   male 4856  9756\r\n15 2013-2014 female 5172 10175\r\n16 2013-2014   male 5003 10175\r\n17 2015-2016 female 5079  9971\r\n18 2015-2016   male 4892  9971\r\n\r\ntotal_grouping(data, year, race_ethnic) %>% \r\n  head(10)\r\n\r\n\r\n        year        race_ethnic    n total\r\n1  1999-2000   mexican-american 3393  9965\r\n2  1999-2000 non-hispanic-black 2228  9965\r\n3  1999-2000 non-hispanic-white 3367  9965\r\n4  1999-2000     other-hispanic  589  9965\r\n5  1999-2000         other-race  388  9965\r\n6  2001-2002   mexican-american 2776 11039\r\n7  2001-2002 non-hispanic-black 2681 11039\r\n8  2001-2002 non-hispanic-white 4606 11039\r\n9  2001-2002     other-hispanic  517 11039\r\n10 2001-2002         other-race  459 11039\r\n\r\ntotal_grouping(data, year, food_security) %>% \r\n  head(10)\r\n\r\n\r\n        year                food_security    n total\r\n1  1999-2000    Food insecure with hunger  499  9965\r\n2  1999-2000 Food insecure without hunger 1209  9965\r\n3  1999-2000            Fully food secure 7102  9965\r\n4  1999-2000       Marginally food secure  889  9965\r\n6  2001-2002    Food insecure with hunger  627 11039\r\n7  2001-2002 Food insecure without hunger 1289 11039\r\n8  2001-2002            Fully food secure 7503 11039\r\n9  2001-2002       Marginally food secure  938 11039\r\n11 2003-2004    Food insecure with hunger  641 10122\r\n12 2003-2004 Food insecure without hunger 1232 10122\r\n\r\nTables\r\nNow, let’s make a table with our output.\r\n\r\n\r\ntemp_table <- percent_grouping(data, year, gender) %>% \r\n  select(year, gender, percent) %>% \r\n  pivot_wider(names_from = gender,\r\n              values_from = percent) %>% t(.)\r\ntable <- temp_table[2:3,]\r\ncolnames(table) <- temp_table[1,] \r\ntable %>% kbl() %>% \r\n  kable_styling(bootstrap_options = \"striped\", full_width = F) %>% \r\n  row_spec(0, angle = -45)\r\n\r\n\r\n\r\n\r\n\r\n1999-2000\r\n\r\n\r\n2001-2002\r\n\r\n\r\n2003-2004\r\n\r\n\r\n2005-2006\r\n\r\n\r\n2007-2008\r\n\r\n\r\n2009-2010\r\n\r\n\r\n2011-2012\r\n\r\n\r\n2013-2014\r\n\r\n\r\n2015-2016\r\n\r\n\r\nfemale\r\n\r\n\r\n51%\r\n\r\n\r\n51.71%\r\n\r\n\r\n50.9%\r\n\r\n\r\n50.91%\r\n\r\n\r\n49.79%\r\n\r\n\r\n50.41%\r\n\r\n\r\n50.23%\r\n\r\n\r\n50.83%\r\n\r\n\r\n50.94%\r\n\r\n\r\nmale\r\n\r\n\r\n49%\r\n\r\n\r\n48.29%\r\n\r\n\r\n49.1%\r\n\r\n\r\n49.09%\r\n\r\n\r\n50.21%\r\n\r\n\r\n49.59%\r\n\r\n\r\n49.77%\r\n\r\n\r\n49.17%\r\n\r\n\r\n49.06%\r\n\r\n\r\nI can generalize this with a function and I’ll make tables for other variables!\r\n\r\n\r\nmy_table <- function(data, var, grouping){\r\n  v1 <- enquo(var) \r\n  v2 <- enquo(grouping)\r\n  temp_table <- percent_grouping(data, !!v1, !!v2) %>% \r\n    select(!!v1, !!v2, percent) %>% \r\n    pivot_wider(names_from = !!v2,\r\n                values_from = percent) %>% t(.)\r\n  table <- temp_table[2:nrow(temp_table),]\r\n  colnames(table) <- temp_table[1,] \r\n  table %>% kbl() %>% \r\n    kable_styling(bootstrap_options = \"striped\", full_width = F) %>% \r\n    row_spec(0, angle = -45)\r\n}\r\n\r\n\r\n\r\n\r\n\r\nmy_table(data, year, gender)\r\n\r\n\r\n\r\n\r\n\r\n1999-2000\r\n\r\n\r\n2001-2002\r\n\r\n\r\n2003-2004\r\n\r\n\r\n2005-2006\r\n\r\n\r\n2007-2008\r\n\r\n\r\n2009-2010\r\n\r\n\r\n2011-2012\r\n\r\n\r\n2013-2014\r\n\r\n\r\n2015-2016\r\n\r\n\r\nfemale\r\n\r\n\r\n51%\r\n\r\n\r\n51.71%\r\n\r\n\r\n50.9%\r\n\r\n\r\n50.91%\r\n\r\n\r\n49.79%\r\n\r\n\r\n50.41%\r\n\r\n\r\n50.23%\r\n\r\n\r\n50.83%\r\n\r\n\r\n50.94%\r\n\r\n\r\nmale\r\n\r\n\r\n49%\r\n\r\n\r\n48.29%\r\n\r\n\r\n49.1%\r\n\r\n\r\n49.09%\r\n\r\n\r\n50.21%\r\n\r\n\r\n49.59%\r\n\r\n\r\n49.77%\r\n\r\n\r\n49.17%\r\n\r\n\r\n49.06%\r\n\r\n\r\nmy_table(data, year, race_ethnic)\r\n\r\n\r\n\r\n\r\n\r\n1999-2000\r\n\r\n\r\n2001-2002\r\n\r\n\r\n2003-2004\r\n\r\n\r\n2005-2006\r\n\r\n\r\n2007-2008\r\n\r\n\r\n2009-2010\r\n\r\n\r\n2011-2012\r\n\r\n\r\n2013-2014\r\n\r\n\r\n2015-2016\r\n\r\n\r\nmexican-american\r\n\r\n\r\n34.05%\r\n\r\n\r\n25.15%\r\n\r\n\r\n24.89%\r\n\r\n\r\n27.51%\r\n\r\n\r\n21.25%\r\n\r\n\r\n22.63%\r\n\r\n\r\n13.89%\r\n\r\n\r\n17%\r\n\r\n\r\n19.27%\r\n\r\n\r\nnon-hispanic-black\r\n\r\n\r\n22.36%\r\n\r\n\r\n24.29%\r\n\r\n\r\n26.31%\r\n\r\n\r\n26.19%\r\n\r\n\r\n21.79%\r\n\r\n\r\n18.57%\r\n\r\n\r\n27.5%\r\n\r\n\r\n22.28%\r\n\r\n\r\n21.35%\r\n\r\n\r\nnon-hispanic-white\r\n\r\n\r\n33.79%\r\n\r\n\r\n41.72%\r\n\r\n\r\n40.83%\r\n\r\n\r\n37.96%\r\n\r\n\r\n40.55%\r\n\r\n\r\n41.95%\r\n\r\n\r\n30.47%\r\n\r\n\r\n36.11%\r\n\r\n\r\n30.75%\r\n\r\n\r\nother-hispanic\r\n\r\n\r\n5.91%\r\n\r\n\r\n4.68%\r\n\r\n\r\n3.37%\r\n\r\n\r\n3.37%\r\n\r\n\r\n11.83%\r\n\r\n\r\n10.75%\r\n\r\n\r\n11.03%\r\n\r\n\r\n9.43%\r\n\r\n\r\n13.12%\r\n\r\n\r\nother-race\r\n\r\n\r\n3.89%\r\n\r\n\r\n4.16%\r\n\r\n\r\n4.6%\r\n\r\n\r\n4.97%\r\n\r\n\r\n4.58%\r\n\r\n\r\n6.1%\r\n\r\n\r\n17.11%\r\n\r\n\r\n15.17%\r\n\r\n\r\n15.51%\r\n\r\n\r\nmy_table(data, year, food_security)\r\n\r\n\r\n\r\n\r\n\r\n1999-2000\r\n\r\n\r\n2001-2002\r\n\r\n\r\n2003-2004\r\n\r\n\r\n2005-2006\r\n\r\n\r\n2007-2008\r\n\r\n\r\n2009-2010\r\n\r\n\r\n2011-2012\r\n\r\n\r\n2013-2014\r\n\r\n\r\n2015-2016\r\n\r\n\r\nFood insecure with hunger\r\n\r\n\r\n5.01%\r\n\r\n\r\n5.68%\r\n\r\n\r\n6.33%\r\n\r\n\r\n5.83%\r\n\r\n\r\n6.25%\r\n\r\n\r\n7.99%\r\n\r\n\r\n7.98%\r\n\r\n\r\n7.3%\r\n\r\n\r\n9%\r\n\r\n\r\nFood insecure without hunger\r\n\r\n\r\n12.13%\r\n\r\n\r\n11.68%\r\n\r\n\r\n12.17%\r\n\r\n\r\n13.02%\r\n\r\n\r\n13.34%\r\n\r\n\r\n14.87%\r\n\r\n\r\n15.05%\r\n\r\n\r\n14.47%\r\n\r\n\r\n16.53%\r\n\r\n\r\nFully food secure\r\n\r\n\r\n71.27%\r\n\r\n\r\n67.97%\r\n\r\n\r\n68.39%\r\n\r\n\r\n69.8%\r\n\r\n\r\n68.25%\r\n\r\n\r\n63.18%\r\n\r\n\r\n62.41%\r\n\r\n\r\n65.41%\r\n\r\n\r\n56.67%\r\n\r\n\r\nMarginally food secure\r\n\r\n\r\n8.92%\r\n\r\n\r\n8.5%\r\n\r\n\r\n8.58%\r\n\r\n\r\n10.1%\r\n\r\n\r\n11.31%\r\n\r\n\r\n12.82%\r\n\r\n\r\n14.05%\r\n\r\n\r\n11.63%\r\n\r\n\r\n14.37%\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2021-06-08T15:25:12-07:00",
    "input_file": "writing-functions.knit.md"
  }
]
